## 并发

并发：逻辑上具有同时处理多个任务的能力
并行：物理上在同一时刻执行多个并发任务

多线程和多进程是并行的基本条件，单线程使用协程（coroutine）做到并发

协程在`单个线程`上通过主动切换来实现多任务并发，优势如下：

1、避免线程切换的开销，因为就在单个线程上下切换

2、可以将阻塞而浪费的时间找回来

协程上运行的多个任务本质上依旧是串行的

goroutine： 运行时会创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。因此看起来 goroutine 更像是多线程和协程的综合体

使用 go 并非执行并发操作，二十创建一个并发任务单元。新建任务呗放置在任务队列中，等待调度器安排合适系统线程取获取执行权，
当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。

goroutine 自定义栈初始仅需 2kb


========

进程退出不会等待并发任务结束，可以使用 Channel 阻塞（demo 02-wait）

如果等待多个任务结束，推荐使用 sync.WaitGroup
sync.Add()
sync.Wait()
sync.Done()

======

可以使用 runtime.GOMAXPROCS() 函数设置最大的线程数： ps:参数小于1， 金返回当前设置值，不做任何调整


===

Gosched: 暂停，释放线程去执行其他任务。 当前任务被放会队列，等待下次调度时恢复执行。

===

Goexit 立即终止当前任务，运行时确保所有已注册延迟调用被执行。

如果在 main.main 中调用 Goexit, 它会等待其他任务结束，然后让进程直接崩溃

===

通道的同步模式和异步模式：

同步模式：必须要有配对操作的 goroutine 出现，否则就会一直阻塞
异步模式：缓冲区未满或数据未读完钱，不会阻塞

====

单向

通道默认是双向的，并不区分发送端和接受端
虽然可以使用 make 创建单向通道，但是那没有任何其他意义，通常使用类型转换来获取单向通道

c := make(chan int)

var send chan <- int = c // 这是一个写单向的，无法通过改变量来读取
var recv <- chan int = c // 这是一个读单向的, 因为你无法通过 close(recv) 来关闭 

可以单独通过 make(<- chan int) 来创建，但是这种做法极其愚蠢，你创建一个只能接收的，就无法给它写入了，同理 make( chan <- int),


~感觉没啥用 因为你照样可以通过 c <- 2 , <-c 来发送和接收~

=====

选择

用于同时处理多个通道，使用 select， 它会随机选择一个可用的通道做收发操作

如果要等所有的通道消息处理结束，可以将已完成的通道设置为 nil， 这样它就会被阻塞，不会被 select 选中 （无论收发， nil 通道都会被阻塞）

如果 select 中的通道是同一个通道，会随机选择

select 可以用于接收，也可以用于发送, select 可以使用 default 来做一些默认的行为

====

