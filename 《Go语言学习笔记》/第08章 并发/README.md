## 并发

并发：逻辑上具有同时处理多个任务的能力
并行：物理上在同一时刻执行多个并发任务

多线程和多进程是并行的基本条件，单线程使用协程（coroutine）做到并发

协程在`单个线程`上通过主动切换来实现多任务并发，优势如下：

1、避免线程切换的开销，因为就在单个线程上下切换

2、可以将阻塞而浪费的时间找回来

协程上运行的多个任务本质上依旧是串行的

goroutine： 运行时会创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。因此看起来 goroutine 更像是多线程和协程的综合体

使用 go 并非执行并发操作，二十创建一个并发任务单元。新建任务呗放置在任务队列中，等待调度器安排合适系统线程取获取执行权，
当前流程不会阻塞，不会等待该任务启动，且运行时也不保证并发任务的执行次序。

goroutine 自定义栈初始仅需 2kb


========

进程退出不会等待并发任务结束，可以使用 Channel 阻塞（demo 02-wait）

如果等待多个任务结束，推荐使用 sync.WaitGroup
sync.Add()
sync.Wait()
sync.Done()

======

可以使用 runtime.GOMAXPROCS() 函数设置最大的线程数： ps:参数小于1， 金返回当前设置值，不做任何调整


===

Gosched: 暂停，释放线程去执行其他任务。 当前任务被放会队列，等待下次调度时恢复执行。

===

Goexit 立即终止当前任务，运行时确保所有已注册延迟调用被执行。

如果在 main.main 中调用 Goexit, 它会等待其他任务结束，然后让进程直接崩溃

===

通道的同步模式和异步模式：

同步模式：必须要有配对操作的 goroutine 出现，否则就会一直阻塞
异步模式：缓冲区未满或数据未读完钱，不会阻塞

====